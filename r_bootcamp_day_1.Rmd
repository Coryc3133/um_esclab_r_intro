---
title: "Introduction to R"
author: "Cory Costello"
date: "9/18/2019"
output: 
  html_document:
    toc: true
    toc_float: true
---

# Goals 

By the end of this tutorial, you will know:

+ Basic `R` usage (using `R` as a calculator, creating variables, indexing)
+ How R represents Data
+ How to read in and examine data
+ How to get values out of the rows and columns in your data
+ Basic iteration (for loops and functions)
+ What a pipe is and how to use pipes to chain together `tidyverse` verbs
+ Begin understanding tidyverse "verbs" (we'll continue on Thursday)

The best way to do this tutorial is to walk through it slowly, executing each line and trying to understand what it does. You can execute a single line by placing your cursor somewhere in that line and hitting CTRL+enter on a PC or CMD+enter on a mac; you can execute a whole chunk at a time by hitting CTRL+shift+enter on a PC. 

# 1. Basic R Use

## 1a. Basic Computing
R can be used as a calculator.

You can do basic arithmetic:

```{r}
# Add
2 + 3
# subtract
2 - 3
# multiplication
2 * 3
# Division
10/2
# Exponents
4^2
# Roots
4^(1/2)
```

Thankfully, R follows the order of operations (PEMDAS).

```{r}
(2^3)+4*(5/3)
```

These values aren't stored anywhere though. This brings me to the first general coding principal of the day:

*Computers tend to take things literally, and do exactly what you ask.* So, when you tell R to divide 6 by 2 (`6/2`), it does exactly that, but it doesn't save it in memory. You have to tell it to do that too.

## 1b. Storing values in objects
To keep a value in memory, we need to assign it to an **object**. 

R has two assignment operators: `=` & `<-`. Let's use these to create an object called x, that is assigned the number 8. 

```{r}
x <- 8 
x = 8
```

Now we can call `x` by name; if we do this, it will print the value.
```{r}
x
```

Although `<-` and `=` both work, we'll strictly use `<-` from here on out. This brings us to our second general coding principal of the day:

*Style is important!* You want to use a consistent style so that others (including your future self) can easily and quickly read your code. I'll be using [Hadley Wickham's Style Guide](http://adv-r.had.co.nz/Style.html) from here on out, part of which is assigning variables with `<-`. Remember, the keyboard shortcut `Alt+-` or `Option+-` can be used to insert a `<-`.

Now, let's take a look at the variable `y`:

```{r eval = FALSE}
# Call Y
y 
```

D'oh! We didn't assign anything to `y`, so R is telling us that it doesn't exist the best way it knows how. 
```{r}
# Need to assign something to y!
y <- 2

y
```

Now, we can use these variables in calculations
```{r}
# add em up:
x + y
# multiply them
x * y
```

But remember, if we want to save *those* calculations, we need to assign them:
```{r}
# define the product as z
z <- x * y
```

### Naming Variables
You may be wondering how to name variables in R. Well, there are just a few rules:

1. object names must start with a letter
2. can contain alphanumeric characters, "_", and ".".
3. R is case sensitive, so `R` and `r` would be different variables.

This is another element of *style*. Using a consistent style when naming variables is crucial to maintaining your sanity. 

Some options include:

+ snake_case
+ SCREAMING_SNAKE (*but why*)
+ camelCase
+ you.can.use.periods (*but don't!*)
  + `.` should be avoided, because it is used to define methods in R and you could end up conflicting with a method name.

I'll be using snake_case (again see [Hadley Wickham's Style Guide](http://adv-r.had.co.nz/Style.html)), but you can change to another option if you'd like.
```{r}
this_is_snake_case <- 8 # a_fine_choice
thisIsCamelCase <- 8 #alsoTotallyWorks
some.maniacs.use.periods <- 8 # probably.best.avoided
And_someTimes.People_doSTRANGEtHiNgS <- 8 # PLEASE NEVER DO ANYTHING LIKE THIS!
```

> **Exercise 1a.** Create two variables. Name them anything you like, and make them both equal to a single number (choose any number you like), and add them together. 

```{r}

```


# 2. Types of Data

## 2a. Types of Values
R has different types of data, and an object's type affects how it interacts with functions and other objects. So far, we've just been working with integers. R has several other types of data:

Type | Definition | Example
-----|------------|--------
Integer | whole numbers from -Inf to +Inf | 1, 2, -1, -10928
Numeric / Double | fractions & decimals from -Inf to +Inf | 1.3, .293764, -.1239217, `Inf`, `-Inf`
Character / String | quoted strings of letters, numbers, and allowed symbols| "1", "one", "o_n_e", "o-n-e", "o.n.e"
Logical / Boolean | logical constants of True or False | TRUE, FALSE, T, F
factor | ordered, labelled variable | variable for year in college labelled "Freshman", "Sophomore", etc.
There are a few special types worth knowing about too:

Type | Definition |Example
-----|------------|-------
NA   | Missing value; technically represented as different types but displayed as NA | NA, NA_character_, NA_integer_
NaN  | 'not a number' | 0/0
+Inf | positive infinity | Inf
-Inf | negative infinity | -Inf
NULL | The NULL object; an object that exists but is completely empty | NULL;

You can use `typeof()` to find out the type of a value or object:

```{r}
typeof(1)
typeof(TRUE)
typeof(1L)
typeof(NA_character_)
typeof(NA)
typeof(NULL)
typeof(NaN)
typeof(Inf)
typeof("one")
```

## 2b. Vectors

Often, we're not working with individual values, but with multiple related values or a *vector* of values. We can create a vector of ordered numbers using `starting_number:ending_number`. For example, we could make `x` a vector with the numbers between 1 and 5:

```{r}
x <- 1:5 # sequence of the form starting_number:ending_number
```

You'll notice that x has changed in the environment pane. Since it's a vector, it tells us what type of vector it is and it's length in addition to its contents (which can be abbreviated if the object is larger). In this case, it's a vector of integers (hence `int`) and is of length 5 (hence `[1:5]`).

We can also create a sequence using the function `seq()`. `seq()` is a function that creates a sequence of numbers. Like all R functions, you can learn more about it by accessing the help documentation (`?+function_name`). Let's take a look:

```{r}
?seq
```

Interpreting R help documention is a skill itself, but a very worthwhile one. I promise that it gets easier. 

What happens if we run `seq()` with no arguments?
```{r}
seq()
```

**Q: Why did this happen?**    

**A: **    

To make a sequence from 1 to 5 with this function, we have to set the `from =` and `to =` to those boundaries:

```{r}
seq(from = 1, to = 5)
```

We can also set one or more of the other arguments. The `by =` argument allows us to change the increment of the sequence. Let's say we wanted every other number between 1 and 5. We can do this by setting `by = 2`

```{r}
seq(from = 1, to = 5, by = 2)
```

We can also create a vector of any numbers we want using the `c()` function. You do this by putting numbers seperated by a `,` within the parentheses. 

```{r}
# We can also assign a vector of values this way
x <- c(2, 8.5, 1, 9)
```

Note that it became a numeric vector (hence `num`), which is different from a vector of integers in that it allows decimal points. This brings us to an important feature of vectors:

Vectors are just 1-dimensional sequences **of a single type of data**. Because `1:5` will just be integers, R stored the vector as `int`. Since we have `8.5` in our new x vector, it will convert x to a numeric vector (which permits decimals). The general rule R uses is to set the vector to be the most permissive type necessary. 

Note that vectors can also include strings or character values.

```{r}
letters <- c("a", "b", "c", "d")
```

What happens if we put the vectors `x` and `letters` together? Let's take a look:

```{r}
mixed_vec <- c(x, letters)
mixed_vec
```

Notice the quotes? R turned all of our numbers into strings, since strings are more permissive than numbers. You can see that by running `typeof()`:

```{r}
typeof(mixed_vec)
```

This is called *coercion*. R coerces a vector into whichever type will accomodate all of the values. We can also coerce a vector ourselves using the `as.` family of functions. Let's coerce mixed_vec into a numeric:

```{r}
as.numeric(mixed_vec)
```


> **Exercise 2a.** Create an object called x that is assigned the number 8. Create an object called y that is a sequence of numbers from 2 to 16, by 2. Add x and y. What happens? 

```{r}
x <- 8
y <- seq(from = 2, to = 16, by = 2)
x + y
```

> **Exercise 2b.** Create an object called z that is a vector containing the numbers 5 and 10. Create an object called q that is a sequence of numbers from 5 to 25, by 5. Multiply q and z. What happens? 

```{r}
z <- c(5, 10)
q <- seq(from = 5, to = 25, by = 5)
q*z
```

> **Exercise 2c.** Create an object called a that is just the letter "a". Add a to x (from above). What happens? 

```{r eval = FALSE}
a <- "a"
a + x
```

> **Exercise 2d.** Create a vector called b that is just the number 8 in quotes. Add b to x (from above). What happens? 

```{r}
b <- "8"
```

> **Exercise 2e** Find the type of each of the objects we just made (x, y, q, z, b)? 

```{r}
typeof(x)
typeof(y)
typeof(q)
typeof(z)
typeof(b)
```

> **Exercise 2e** Find some way to add b to x (hint: you may need to be coercive)? 

```{r}
as.numeric(b) + x
```

### Indexing vectors

The last thing to mention about vectors is that they are all indexed numerically in R, starting with 1. Since vectors are only 1 dimension, we index them with a single number in `[]`. Let's get just the first element of the vector `q` we made in the exercises above:

```{r}
q[1]
```

What if we wanted the first two elements? We could do this by passing the sequence `1:2` as our index:

```{r}
q[1:2]
```

Or, we could get the first and third element by passing those indexes as a vector using `c()`:

```{r}
q[c(1, 3)]
```

Finally, if the elements in the vector have names, we can refer to them by name instead of their numerical index. You can see the names of a vector using `names()`

```{r}
names(q)
```

Looks like the elements in X have no names. We can change that by assigning them names using a vector of names:

```{r}
names(q) <- c("first", "second", "third", "fourth", "fifth")
```

And we can see the names:

```{r}
names(q) 
```

And use them to subset certain elements

```{r}
q["first"]
q[1]
```

> **Exercise 2f.** Create a vector called `named` that includes the numbers 1 to 5. Name each value a, b, c, d, and e (in order). Print the first element using numerical indexing and the last element using name indexes. 

```{r}
named <- 1:5
names(named) <- c("a", "b", "c", "d", "e")
named[1]
named["e"]
```

## 2c. Lists

Vectors are great for storing a single type of data, but what if we have a variety of different kinds of data we want to store together. For example, let's say I want to store the year I am in the PhD program (a number), my name ( a string), and my enrollment status (a logical) in a single object that preserved these different types? A vector won't work, but a `list` will.

Lists are like vectors in that they are a 1-dimensional object, but they can contain heterogeneous data. We can create a list with the `list()` function:

```{r}
cory <- list(5L,
             "Cory Costello",
             TRUE)

cory
```

And, we can give each of these entries names to make things a little easier to keep track of:

```{r}
cory <- list(year = 5L,
             name = "Cory Costello",
             enrollment = TRUE)

cory
```

Notice that the `[[1]]`, `[[2]]`, and `[[3]]`, the element indices, have been replaced by the names `year`, `name`, and `enrollment`. You can see also see the names of a list by running `names()` on it:

```{r}
names(cory)
```

Lists are even more flexible than you've seen so far. In addition to being of heterogeneous type, each element of a list can be of different dimensions. Let's add another element to the list about me that contains my favorite types of data, which will be a vector of length 2:

```{r}
cory <- list(year = 5L,
             name = "Cory Costello",
             enrollment = TRUE, 
             fave_data = c("strings", "numbers")) # note c() to create a vector
cory
```

### Indexing Lists

Like vectors, lists can be indexed by their name or their position (numerically). For example, if we wanted the year variable, we could get it out using its position as the first element of my list:

```{r}
cory[1]
```

Now let's say we want to know my PhD year in dog years. Let's see if we can get that by multiplying the `year` element by 7:

```{r eval = FALSE}
cory[1] * 7
```

Okay, we get a pretty confusing error that we supplied a non-numeric argument, which in this case is `cory[1]`. This happened because single bracket indexing on a list produces a list and lists can't be multiplied by a number (at least not with just `*`). If we want the actual object stored at the first position instead of a list with that object, we have to use the double-bracket indexing `list[[i]]`:

```{r}
cory[[1]]
```

Notice it no longer has the `$year`; `$label` is a hint that you're looking at a list and not the object stored at that position. Now let's see my PhD year in dog years:

```{r}
cory[[1]] * 7
```

The same applies to name indexing. With lists, you can get a list containing the indexed object with `[]`:

```{r}
cory["year"]
```

And double brackets `[[]]` can be used to get the object stored with that name:

```{r}
cory[["year"]]
```

You can also use `list$name` to get the object stored with a particular name too:
```{r}
cory$year
```

> **Exercise 2g.** Create a list like mine that is made up of `year`, `name`, `enrollment`, `fave_data`, but corresponds to you (professors can use years as a prof, years since PhD, or make a number up). Make sure you enter two types of favorite data (bc who could choose?!). Make it print your name.

```{r}

```


### Indexing Objects within Lists

As we saw with the object `fave_data` stored in the list `cory`, objects within lists can have different dimensions and length. What if we wanted just one element of an object in a list, such as just the second element of `fave_data`? We can use indexing on the `fave_data` vector stored within the `cory` list by chaining indexes.

We could do that with numbers:

```{r}
cory[[4]][2]
```

Or with type of list name indexing:

```{r}
cory[["fave_data"]][2]
```

```{r}
cory$fave_data[2]
```

 > **Exercise 2h.** Using the same list, get your PhD year in dog years (`*7`) and assign it to the 2nd position of the `year` object. Then show the new `year` object.
 
```{r}
cory$year[2] <- cory$year*7
cory$year
```
 
## 2d. Matrices & Arrays

Matrices are 2-dimensional objects that store a single type of data, so you can think of them like a 2-dimensional vector. For example, we could create a 2 X 2 matrix of the numbers 1 to 4 with the `matrix()` function.

```{r}
mat <- matrix(data = c(1, 2, # data in either row-wise or column-wise order
                       3, 4), # don't have to do two lines, but it looks nice
              nrow = 2, # number of rows
              ncol = 2, # number of columns
              byrow = TRUE) # tell it the order of data above
mat
```

Or, let's say we had two columns, c1 and c2. We could put them together into a matrix using `cbind()` or column-bind:

```{r}
c1 <- c(1, 3)
c2 <- c(2, 4)
mat <- cbind(c1, c2)
mat
```

This accomplishes basically the same thing, except our two columns have names. 

We could do something similar with two rows, called r1 and r2, using the `rbind()` or row-bind function:

```{r}
r1 <- c(1, 2)
r2 <- c(3, 4)
mat <- rbind(r1, r2)
mat
```

This is essentially the same, but it has row names. We can see that by running `rownames()` on it:

```{r}
rownames(mat)
```

You'll notice it doesn't have column names, which we can check with `colnames()`:

```{r}
colnames(mat)
```

But, we could assign column names using the `colnames()` function:

```{r}
colnames(mat) <- c("c1",  "c2")
mat
```

Finally, matrices behave a lot like vectors; they can only accomodate homogenous data, and so it will coerce the data into whatever type is most accomodating:

```{r}
mixed_mat <- cbind(mat, 
                   c3 = c("a", "b"))
mixed_mat
```

Note that it has now turned everything into strings.

### Indexing Matrices

Indexing matrices is just like indexing vectors, except we have two dimensions, which we use like so:    
[row, column]

Let's get the element at row 1 column 1 of the `mat` object:

```{r}
mat[1, 1]
```

Or we could get the whole 2nd column by leaving the row index blank:

```{r}
mat[,2]
```

And, we can use names instead of numbers if we like:

```{r}
mat["r1", "c1"]
```

A mix:
```{r}
mat["r1", 2]
```

 > **Exercise 2i.** Make a matrix called mat2 that is a 3 X 3 matrix with rows 1, 2, 3,  4, 5, 6,  7, 8, 9. Make the column names c1, c2, and c3, and make the row names r1, r2, and r3. Add the first column to the third column.

```{r}
mat2 <- matrix(c(1, 2, 3, 
                 4, 5, 6, 
                 7, 8, 9),
               nrow = 3, 
               byrow = TRUE)

mat2[,1] + mat2[,3]
```
 
 
> **Exercise 2j.** Multiple the 3rd row by the value in the 2nd row and 2nd column.

```{r}
mat2[3,] * mat2[2, 2]
```

### Arrays

Arrays are like matrices, but can have N-dimensions (more than 2).

```{r}
array(c(mat2, mat2*2), dim =c(3, 3, 2))
```

Most of us don't have to use arrays much, so we'll leave it at that.

## 2e. Data Frames

Now you might be thinking 'what's all this noise about vectors, lists, matrices, and arrays? I work with data!' Well, R has a type for you too! The `data.frame` object is like a matrix in that it has 2 dimensions, but it can contain heterogeneous data like a list. The indexing works like a sort of hybrid of the two as you'll soon see.

Let's start by making a simple dataframe out of the `mixed_mat` we created above:

```{r}
df_1 <- data.frame(mixed_mat)
df_1
```

Note that we can also create a dataframe very similarly to how we made a list, but replacing `list()` with `data.frame()`:

```{r}
df_1 = data.frame(c1 = c(1, 3),
                  c2 = c(2, 4), 
                  c3 = c("a", "b"),
                  row.names = c("r1", "r2"))
```

### Indexing Data Frames

Indexing dataframes is sort of a hybrid between matrices and lists. Like matrices, you can index using the [row, column] format, using either numerical indexing:

```{r}
df_1[1, 3]
```

or names: 

```{r}
df_1["r1", "c3"]
```

You can also get an entire row or column by leaving an index blank. Let's get all rows for column 2:

```{r}
df_1[, "c2"]
```

However, like a list, we can use the `$` in the form `data$column` (similar to `list$object` used for lists). Let's get the first column:

```{r}
df_1$c1
```

And, like with lists, we can index a column using vector indexing, since a single column is (by definition) a vector (1-dimensional, with a single type of data). Let's get the first value in column 1:

```{r}
df_1$c1[1]
```


### Structure, Types, & Coercion in Dfs
How can we tell what type of data each column stores? We can use the `str()` function to get the *structure* of the data:

```{r}
str(df_1)
```

> **Exercise 2k.** Make a data frame, called df_2, that has 3 columns (hint: you can use cbind to put vectors together into a dataframe).

c1 = 1, 2, 3
c2 = 2, 4, 6,
c3 = "a", "b", "c"

> After you create it, check the structure.

```{r}

df_2 <- data.frame(c1 = c(1, 2, 3), 
                   c2 = c(2, 4, 6), 
                   c3 = c("a", "b", "c"))
str(df_2)
```

> **Exercise 2l.** Using df_2, add the first and second columns together. what happens? Why?

```{r}
df_2$c1 + df_2$c2
```

> **Exercise 2m.** Using df_2, try to add the first and second rows together. what happens? Why?

```{r}
df_2[1,] + df_2[2,]
```

## Wrapping up Data Types

Now you know the basics of how R represents data.

This table from [Advanced R](http://adv-r.had.co.nz/Data-structures.html#data-structures) summarizes them:

| | Homogenous data | Heterogenous data |
|------------|----------------| ------------------|
| 1-Dimensional | Atomic Vector | List |
| 2-Dimensional | Matrix | Data frame |
| N-Dimensional | Array | |

# 3. Functions & Iteration

## 3a. Basic Functions

Data (and objects more generally) are one of the building blocks of R. The other is functions. We've already used a handful of functions, including `seq()`, arithmetic functions (`+`, `*`, etc.), `matrix()`, `array()`, etc.

Functions take some form of an input, perform some operation, and then return some object(s) as output. Functions are made up of *arguments*. For example, let's take a look at the help documentation for `seq()` by copying ?seq into the console.

You can see it has the arguments `from`, `to`, `by`, `length.out`, and `along.with`. You might also notice that each of the arguments have a value after the `=` in the documentation. These values are the *defaults*; they are what the arguments will be set to if you don't specify them. In fact, since all of the arguments have defaults, we don't have to specify any to run `seq()` as we saw earlier today.

```{r}
seq()
```

Let's take a look at a new function, `mean()`. This is used to get the mean of a set of numbers. What happens if we run it without any arguments?

```{r eval = FALSE}
mean()
```

We get an error telling us that the argument "x" is missing and has no default. Whenever you see this error, it means you are missing a required argument (i.e., an argument without a default). If we look at the documention, you can see x is the data from which to calculate a mean.

Let's see what happens when we run `mean()` on the matrix `mat2` we create

```{r}
mean(mat2)
```

Note that `mean()` has two more optional arguments listed: `trim`, which returns a trimmed mean, and `na.rm` which takes a logical value indicating if it should remove missing values or not before it calculates the mean (set to `FALSE` by default). What happens if we don't remove NAs before calculating the mean? Let's check it out.

```{r}
vec_w_na <- c(1, 2, 3, 4, 5, 6, NA, 2, 4)
mean(vec_w_na)
```

It returns `NA`. This is important to remember: NAs are contagious! One in a vector will cause many functions to return NA (unless they remove them by default). This sort of makes sense - the mean of `vec_w_na` in its entirity is unknown, since we don't know what the `NA` value is. That's why you have to remove them by setting `na.rm = TRUE`

```{r}
mean(vec_w_na, na.rm = TRUE)
```

`sd()` can be used to get the standard deviation and is structured very similarly:

```{r}
sd(vec_w_na, na.rm = TRUE)
```

You can get the length of many objects with `length()`:

```{r}
length(vec_w_na)
```

`nrow()` and `ncol()` can be used to get the number of rows or columns in a matrix or data frame:

```{r}
nrow(df_2)
ncol(df_2)
nrow(mat)
ncol(mat)
```

## 3b. Arguments are Positional

Take another look at the `sd()` function documentation (`?sd`). Notice that there are two arguments and they are in order, `x` followed by `na.rm = FALSE`. You can set arguments by name:

```{r}
sd(x = vec_w_na, na.rm = TRUE)
```

You can also set them positionally:

```{r}
sd(vec_w_na, TRUE)
```

When using arguments positionally (without their names), you **need to make sure the arguments are in the right order.** If you name the arguments, you can actually put them in a different order:

```{r}
sd(na.rm = TRUE, x = vec_w_na)
```

Now let's try the `mean()` function:

```{r eval = FALSE}
mean(vec_w_na, TRUE)
```

**Q: What happenned?**     
**A: trim is in the second position, not na.rm = TRUE. This is the risk of using positional arguments, especially if the mistake has a more subtle effect.**

## 3c. User-defined functions

You can also make your own functions. In fact, that is where most of the R functions we use come from, someone making their own function and then sharing it with everyone. For example, let's make a function that calculates the mean of a vector, and prints it in the format: "The mean is _", where the blank is filled in with the mean.

To create a function, you use the `function()` function. Like anything you make in R, you need to save it to a name with `<-`.

Within the parantheses, you put the arguments. Then you define the *body* of the function in `{}`:

```{r}
pretty_mean <- function(data){
  mean <- mean(data, na.rm = TRUE)
  paste("The Mean is", mean)
}
```

Now let's test it out on our `vec_w_na` object:

```{r}
pretty_mean(vec_w_na)
```

Notice that it works how we expected it to, and also it didn't create an object in our global environment called `mean`. That variables within a function are local; they only exist within that function (they don't get created in the global environment). 

Obviously, we can make much more complicated functions, but we will leave it there for now.

> Exercise 3a. Create a function called `pretty_sd`, that has a single argument called data and prints out "The SD is _" with the blank filled in with the SD of the data. Run it on the `vec_w_na` object.

```{r}
pretty_mean <- function(data){
  mean <- sd(data, na.rm = TRUE)
  paste("The SD is", mean)
}

pretty_mean(vec_w_na)
```

### For loops

R, like many programming languages, can loop through objects. The most common type of loop is called a *for loop*, and it iterates through an object performing a specified operation. For example, let's say we wanted to go through our `vec_w_na` and print each element and its index. We could do that with a for loop.

For loops work a little bit like a function. Within the parantheses, you specify what is being iterated through, and you specify the bodfy of the loop in `{}`:

```{r}
for(i in 1:length(vec_w_na)){
  print(paste("The value at index", i, "is", vec_w_na[i]))
}
```

Note that with a for loop, we have to tell it to print the result; otherwise, it runs the commands within the scope of the loop and doesn't display the results. 


> Exercise 3b. Create a for loop that iterates through our `vec_w_na` vector, and prints out the result of dividing each value by 5 (hint: remember to print!).

```{r}
for(i in 1:length(vec_w_na)){
  print(vec_w_na[i]/5)
}
```


# 4. Reading data into R

First, you'll need to tell R where to look for the data. To do this, you will set your working directory. 

For this tutorial, your working directory should be wherever you downloaded the materials. (They should be on your desktop.)

```{r}

# What is my current working directory?
getwd()

# How can I change my working directory?
#setwd(")
getwd()

# What is in my working directory?
dir()

```

You can also do this using RStudio, via the graphical interface on the top:

Session > Set Working Directory > Choose Directory

You can choose the folder you want to work in. The code for setting the working directory will populate in the console. You can then copy/paste this into your code if you'd like.

```{r}
#install.packages("rio")
library(rio)
# Now, let's read in the pragmatic_scales_data CSV file and save it as an object called ps_data
ps_data <- import("pragmatic_scales_data.csv", header = TRUE)

```

> ProTip: You can also read in data files generated by other programs like SPSS. There are often packages to help with this.

Here's how you could read in this file if it were an SPSS file. (The code below won't work because the file is a .csv)
```{r}
# Uncomment the line below to install the `foreign` package
#ps_data_spss <- import('pragmatic_scales_data.sav')

```

# Examining the data file

You should now see the dataset in your environment.

We can simply look at the data frame. We can also get a summary of the data. (these are all **functions** too!)

```{r}
# Look at the first few rows of the data.
head(ps_data)

# Look at the final few rows of the data.
tail(ps_data)

# You can also specify the number of rows you'd like to see
head(ps_data, n = 10)
tail(ps_data, n = 2)

# Get a summary of the data.
summary(ps_data)

# You can also `View` data, which shows an interactive "spreadsheet" view. You can also get this by clicking on the dataset in the environment.
View(ps_data)

# Note the capital `V`
#view(ps_data) #this doesn't work!

# We can also look at the structure of the data.
str(ps_data)

# I can get the column names of the data.
colnames(ps_data)

```

> **Exercise 5a.** Move the file called `another_data_set.csv` from the `uoregon_r_bootcamp` folder on your desktop to a different folder on your computer. Re-set your working directory to that folder. Use `getwd()` to make sure you have the right directory. Read in this new dataset and name it anything you'd like. Use head/tail/summary/etc to check out this data set.

Once you've read in that data file, reset your working directory to the `uoregon_r_bootcamp` folder on your desktop.
```{r}


```
# 6. Indexing and modifying a data frame.

You can select entries in the data frame just like indexing a vector. [row, column]

```{r}
# Get the entire `condition` column.
ps_data[,5]
ps_data[,"condition"]

# Get the entry in row 3, column 4.
ps_data[3, 4]

# Get the entry in row 4 of the item column
ps_data[4, "item"] 
```

> ProTip: Many people use this kind of selection to modify individual entries, like if you just want to correct a single mistake at a paticular point in the data frame. Be careful if you do this, as there will be nothing in the code that tells you that `4` is the *right* element to fix, you'll just have to trust that you got that number right. 
```{r}
# For example:
ps_data[4, "item"] <- "faces"

# Now that entry is changed to "faces"

# Change it back:
ps_data[4, "item"] <- "beds"

# You can do this with column names, too. Maybe I want to change the name of the `item` column to `image`.
colnames(ps_data)[2] <- "image"
colnames(ps_data)
head(ps_data)

# Change it back:
colnames(ps_data)[2] <- "item"

# You can also select an entire column using the $ operation.
ps_data$condition

# ...or ask for only the unique entries from that column
unique(ps_data$condition)

# ...or get the frequency of each unique value
table(ps_data$condition)

# You can also use `table` with multiple variables
table(ps_data$condition, ps_data$item)

# Create a new column from a current column(s).
ps_data$new <- ps_data$age + ps_data$correct
head(ps_data)

# Adding age and correct doesn't make sense. Let's delete that column.
ps_data$new <- NULL
head(ps_data)

```

We can apply functions to an entire column. For example, I can get the mean age for my entire sample.

Note that I have to include the data file in this argument, if I just say mean(age) I'll get an error.

```{r}
#mean(age) # doesn't work! I don't  have anything in my environment called "age"

mean(ps_data$age)
```

> **Exercise 6a.** Let's center age. Create a new column called age_centered in which you center age by subtracting the mean age from the age column.

```{r}


```

# Using the `tidyverse`

Content adapted from: https://github.com/mcfrank/tidyverse-tutorial

  > tidyverse is a package that has to be installed and loaded before you can use any of its functions.
  
The functions we've been using so far have been in **base R** and don't require additional packages. To use the functions in the tidyverse packages the `tidyverse` package must first be installed and loaded. Tidyverse packages include tidyr, dplyr, ggplot2, and more - see here for more info: www.tidyverse.org.
  
If you haven't installed the package, you'll need to run this command once:

`install.packages("tidyverse")`

```{r}
# Load the package (tell R that you want to use its functions)
library("tidyverse")
```

We're going to reread the data now, using `read_csv`, which is the `tidyverse` version and works faster and better in a number of ways!

```{r}
ps_data <- read_csv("pragmatic_scales_data.csv")
```


# 7. Pipes

Pipes are a way to write strings of functions more easily. They bring the first argument of the function to the beginning. So you can write:

```{r}
mean(ps_data$age)

# becomes...

ps_data$age %>% mean()
```

That's not very useful yet, but when you start **nesting** functions, it gets better. 

```{r}
mean(unique(ps_data$age))
ps_data$age %>% unique() %>% mean()
ps_data$age %>% unique %>% mean
```

or 

```{r}
round(mean(unique(ps_data$age)), 
      digits = 2)

ps_data$age %>% unique %>% mean %>% round(digits = 2)

# indenting makes things even easier to read
ps_data$age %>%
  unique %>% 
  mean %>% 
  round(digits = 2)
```

This can be super helpful for writing strings of functions so that they are readable and distinct. 

> **Exercise 7a.** Rewrite these commands using pipes and check that they do the same thing! (Or at least produce the same output). 

Unpiped version: length(unique(ps_data$item))

```{r}



```
# 8. Quick Intro to Tidyverse

Using `tidyverse` to explore and characterize the dataset

We are going to manipulate these data using "verbs" from `dplyr`. Here are four verbs that are common in many workflows (but there are many other useful ones):

+ `filter` - remove rows by some logical condition
+ `mutate` - create new columns 
+ `group_by` - group the data into subsets by some column
+ `summarise` - apply some function over columns in each group  

Inspect the various variables before you start any analysis. Earlier we used `summary` but it's not always very useful. 

```{r}
summary(ps_data)
```

This output just feels overwhelming and uninformative. 

You can look at each variable by itself:

```{r}
unique(ps_data$item)

ps_data$subid %>%
 unique 
```

Or use interactive tools like `View` or `DT::datatable` (which I really like).

```{r}
# this won't work unless you first do
# install.packages("DT")
DT::datatable(ps_data) 
```

> ProTip: What we're working with is called "tidy data" where each column is one measure, and each row is one observation. This is, by consensus, the best way to work with tabular data in R. It's actually where the name of `tidyverse` comes from. Check out [this paper](https://www.jstatsoft.org/article/view/v059i10) to learn more. BUT - if you normally work with "wide data", where each row is a subject and different trials are different columns (like what SPSS often does), you can get your data "tidy" using a package called `tidyr`, which is also part of the tidyverse. It's a little tricky so we're not teaching it today, but the verbs that it provides are `gather` and `spread`. 

## Filtering & Mutating

There are lots of reasons you might want to remove *rows* from your dataset, including getting rid of outliers, selecting subpopulations, etc. `filter` is a verb (function) that takes a data frame as its first argument, and then as its second takes the **condition** you want to filter on. 

So if you wanted to look only at 2 and 3 year olds.

```{r}
ps_data %>%
  filter(age > 2, age < 3)

# filter(ps_data, age > 2 & age < 3)

```

Note that we're going to be using pipes with functions over data frames here. The way this works is that:

+ `dplyr` verbs always take the data frame as their first argument, and
+ because pipes pull out the first argument, the data frame just gets passed through successive operations
+ so you can read a pipe chain as "take this data frame and first do this, then do this, then do that."

This is essentially the huge insight of `dplyr`: you can chain verbs into readable and efficient sequences of operations over dataframes, provided 1) the verbs all have the same syntax (which they do) and 2) the data all have the same structure (which they do if they are tidy). 

OK, so filtering:

```{r}
ps_data %>%
  filter(age > 2, 
         age < 3)

```

**Exercise.** Create a smaller datast with **only** the "faces" items in the "Label" condition.

```{r}


```

> ProTip: You can think about `filter`ing as similar to "logical indexing", where you use a vector of `TRUE` and `FALSE`s to get a part of a dataset, for example, `ps_data[ps_data$items == "faces",]`. This command creates a logical vector `ps_data$items == "faces"` and uses it as a condition for filtering.

There are also times when you want to add or remove *columns*. You might want to remove columns to simplify the dataset. If you wanted to do that, the verb is `select`. 

```{r}
ps_data %>%
  select(subid, age, correct) 

ps_data %>%
  select(-condition) 

ps_data %>%
  select(1) 

ps_data %>%
  select(starts_with("co")) 

# learn about this with ?select
```

Perhaps more useful is *adding columns*. You might do this perhaps to compute some kind of derived variable. `mutate` is the verb for these situations - it allows you to add a column. Let's add a discrete age group factor to our dataset.

```{r}
ps_data <- ps_data %>%
  mutate(age_group = cut(age, 2:5, include.lowest = TRUE), 
         age_centered = age - mean(age))

head(ps_data)

```


## Standard psychological descriptives

We typically describe datasets at the level of subjects, not trials. We need two verbs to get a summary at the level of subjects: `group_by` and `summarise` (kiwi spelling). Grouping alone doesn't do much.

```{r}
ps_data %>%
  group_by(age_group) 
```

All it does is add a grouping marker. 

What `summarise` does is to *apply a function* to a part of the dataset to create a new summary dataset. So we can apply the function `mean` to the dataset and get the grand mean. 

```{r}
## DO NOT DO THIS!!!
# foo <- initialize_the_thing_being_bound()
# for (i in 1:length(unique(ps_data$item))) {
#   for (j in 1:length(unique(ps_data$condition))) {
#     this_data <- ps_data[ps_data$item == unique(ps_data$item)[i] & 
#                       ps_data$condition == unique(ps_data$condition)[n],]
#     do_a_thing(this_data)
#     bind_together_somehow(this_data)
#   }
# }

ps_data %>%
  summarise(correct = mean(correct))
```

Note the syntax here: `summarise` takes multiple  `new_column_name = function_to_be_applied_to_data(data_column)` entries in a list. Using this syntax, we can create more elaborate summary datasets also:

```{r}
ps_data %>%
  summarise(correct = mean(correct), 
            n_observations = length(subid))
```

Where these two verbs shine is in combination, though. Because `summarise` applies functions to columns in your *grouped data*, not just to the whole dataset!

So we can group by age or condition or whatever else we want and then carry out the same procedure, and all of a sudden we are doing something extremely useful!

```{r}
ps_means_nosubgrouping <- ps_data %>%
  group_by(age_group, condition) %>%
  summarise(correct_mean = mean(correct),
            correct_sd = sd(correct),
            n_observations = length(subid))
ps_means_nosubgrouping
```

> **Exercise.** One of the most important analytic workflows for psychological data is to take some function (e.g., the mean) *for each participant* and then look at grand means and variability *across participant means*. This analytic workflow requires grouping, summarising, and then grouping again and summarising again! Use `dplyr` to make the same table as above (`ps_means`) but with means computed across subject means, not across all data points. Then, take that data and get means for age_group and condition. (The means will be pretty similar as this is a balanced design but in a case with lots of missing data, they will vary.) 

```{r}


```

## Playing around with SWIRL

```{r}

# I highly recommend trying out the swirl package!

#install.packages("swirl") # give it time to install, if you're using R Studio you'll see a little 
# stop sign in the top right corner of the console until it's finished installing.
#library(swirl)
#swirl()  # have fun! :)

```
