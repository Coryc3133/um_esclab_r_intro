---
title: "Introduction to R"
author: "Jessica Kosie"
date: "9/21/2018"
output: 
  html_document:
    toc: true
    toc_float: true
---

# Goals 

By the end of this tutorial, you will:

+ have a better understanding of tidyverse `verbs`
+ understand the basics of graphing in ggplot2
+ understand the basics of writing in RMarkdown (content in a separate document)

The best way to do this tutorial is to walk through it slowly, executing each line and trying to understand what it does. You can execute a single line by placing your cursor somewhere in that line and hitting CMD+enter on mac or CTRL+enter on PC. 

# 1. Data tidying with `tidyr`
Credit: http://r4ds.had.co.nz/tidy-data.html#tidy-data-1

The two key verbs in **data tidying** are `spread` and `gather`. Each of these verbs relies on a key-value pair that contains a *key* that indicates *what* the information describes and a *value* that contains the actual information.

"Password: 0123456789"" is a key value pair. 0123456789 is the *value*, and it is associated with the *key* Password.

The `ps_data` we've been using is already *tidy*. Now, we'll look at some that are not! We'll use some datasets that are built into the tidyverse package. Each dataset has the same values of four variables, `country`, `year`, `population`, and `cases`, but each dataset organizes them in different ways.

Recall the "rules" for tidy data:
+ Each variable must have its own column.
+ Each observation must have it's own row.
+ Each value must have its own cell.

```{r}
?table1 #let's learn about the datset
table1 #this dataset is tidy!
```
## 2.1. Gathering Data

A common problem is a dataset where some column names are not names of variables, but *values* of a variable. Check out `table4a`. 

```{r}
table4a
```

The column names `1999` and `2000` are not variables in our data, instead they represent values of the `year` variable, and each row represents two observations, not one. We need to *gather* these columns into a new pair of variables.

*gather* makes wide tables narrower and longer

There are three questions we must answer:
> 1. Which columns do we want to gather? 
> A: `1999` and `2000`
> 2. What is the name ofthe variable whose values form the column names (the *key*)? 
> A: year
> 3. What is the name of the variable that is spread out over the cells (the *value*)? > A: cases

We'll use these answers in the *gather* function:
```{r}
table4a %>% 
  gather(`1999`, `2000`, key = "year", value = "cases")

```

Note that we had to wrap 1999 and 2000 in backticks. This is because they violate column naming rules (remember, they shouldn't start with numbers), and so we have to tell R more explicitly that these are in fact names with the backtick. 

> **Exercise 2.1a.** `table4b` contains information about the `population` variable. Let's *gather* that table as well. Type `table4b` to check it out before gathering. Your resulting table should have columns for `country`, `year`, and `population`.

```{r}
table4b #check it out

table4b %>% 
  gather(`1999`, `2000`, key = "year", value = "population")
```

### 2.1.1 Gathering & Joining 

Note that table4a contained our `cases` data while table4b contained our `population` data. Everything else is the same. Let's join those two tables together using `left_join`, which we covered very briefly yesterday (more about joining data frames [here](http://r4ds.had.co.nz/relational-data.html)).

```{r}
tidy4a <- table4a %>% 
  gather(`1999`, `2000`, key = "year", value = "cases")

tidy4b <- table4b %>% 
  gather(`1999`, `2000`, key = "year", value = "population")

left_join(tidy4a, tidy4b) #note that R tells you which columns were matched

```

## 2.2 Spreading Data

In contrast to *gather*ing, sometimes a single observation is scattered across multiple rows. Then, you'd want to use *spread* (which is the opposite of *gather*). Let's look at table 2:

```{r}
table2
```

In table2, a single observation is a country in a year, but each observation is spread across two rows. We would want to `spread()` the `type` variable into columns.

*spread* makes long tables shorter and wider

Now, there are two questions we must answer:
> 1. Which column contains the variable names (i.e., the *key* column)? 
> A: `type`
> 2. Which column contains the *values* (or the data from multiple variables)? 
> A: `count`

We'll use these answers in the *spread* function:
```{r}
table2 %>% 
  spread(key = type, value = count)
```
> **Exercise 2.2a.** Let's play around with our ps_data. Make each `item` a unique variable. Use *spread* to reformat the data so that there is a unique column for each item. The values in each of the four `item` columns should indicate whether or not the subject got that particular item right or wrong (i.e., `correct` in ps_data). Hint: what is the *key*? What is the *value*? Do not save this as a new object.

```{r}
ps_data %>% 
  spread(item, correct)
```

## 2.3 Uniting and separating columns
In addition to making datasets longer (with `gather()`) and wider (with `spread()`), we can also `unite()` multiple columns into one, or `separate()` columns into multiple new columns.

### 2.3.1 `separate()`

You can `separate()` one column into multiple columns using the `tidyr` function `separate()`. It takes data as its first argument, then the column you want to separate (`col = `), then a vector of quoted names for the new columns (`into = `), and then what character to split values by (`sep = `).

Let's use the starwars data from yesterday to split each character's `name` into `first_name` and `last_name`. Let's start without setting the `sep = ` argument to see what it does by default:

```{r}
starwars %>% 
  separate(col = name, into = c("first_name", "last_name"))
```

You might notice that it separated based on different characters, such as white space (luke & skywalker were separated) and by hyphens (C and 3PO were separated). By default, it separate looks for common separators (space, hyphen, underscore, periods, etc.) and uses all of them. This can be useful, but it has undesirable effects, like separating Obi-Wan's first name into two pieces. Let's fix this by telling separate to use white space to separate first from last names using the `sep = ` argument:

```{r}
starwars_sep_names <- starwars %>% 
  separate(name, c("first_name", "last_name"), sep = " ")

starwars_sep_names
```

### 2.3.2 `unite()`

`unite()` is the complement of `separate()` and used to join the contents or values of different columns into one new column. It requires data as its first argument, then the unquoted name of the new column name, followed by unquoted names of columns you wish to unite. Let's try to put the first and last names of starwars characters back together with `unite()`:

```{r}
starwars_sep_names %>% 
  unite(col = name, first_name, last_name)
```

Okay, so a couple of things went wrong:
1. It put an "_" between first and last names; we can easily change this to whitespace using `sep = " "`. 
2. It merged in the NAs for characters without last names. This is more challenging and requires tools from other libraries.

We'll fix this here, but mainly use this as a warning to be careful when you're uniting columns!

```{r}
starwars_sep_names %>% 
  unite(col = name, first_name, last_name, sep = " ") %>% 
  mutate(name = str_remove_all(name, "NA")) # overwrite name with 
                                            # name with NAs removed
```

## 3. Graphing in ggplot2

Now let's talk about one of the best parts of the tidyverse and R more generally: ggplot2. 

ggplot2 is the *grammar of graphics*, and is the tidyverse package for creating plots. Even with just a few of its commands, it can make beautiful, publication-ready plots. Its more advanced features add even more versatility. And, people make companion packages for it to do even more (e.g., `ggpubr` to  add statistics to your plot).

Note, what we'll cover today is just the beginning! There are [entire books on graphing in ggplot2!](https://www.amazon.com/ggplot2-Elegant-Graphics-Data-Analysis/dp/331924275X/ref=as_li_ss_tl?ie=UTF8&linkCode=sl1&tag=ggplot2-20&linkId=4b4de5146fdafd09b8035e8aa656f300).

Last note, I'm borrowing heavily from [this guide](https://uodatascience.github.io/R_Guide/plotting.html) that Jonny Saunders put together. 

For this section we're going to use another dataset that is built into R. It is called `iris` and it is the cannonical ggplpot2 dataset. Let's start by making a scatter plot of the relationship between Sepal.Length and Petal.Length.

```{r eval = FALSE}
?iris # first, let's learn about the dataset
head(iris)
```

When creating a plot in ggplot2, the first thing you have to do is call the `ggplot()` function. It takes data as its first argument. Let's start there:

```{r}
ggplot(data = iris)
```

And, nothing happened. To understand why, let's back up to the philosophy of ggplot:

## 3.1 Philosophy of ggplot 

What is a statistical graphic? According to  [Wickham](http://www.tandfonline.com/doi/abs/10.1198/jcgs.2009.07098), we can thing of statistical graphics as:

* **Mappings** from data to aesthetic attributes (colour, shape, size) 
* Of **geometric objects** (points, lines bars)
* On a particular **coordinate system** (or scale)
* Sometimes after a statistical **transformation**

We'll follow their lead. In ggplot, that combination of things forms a *layer*. The terminology in ggplot is

* **aes** - aesthetic mappings
* **geom** - geometric objects
* **scale** - ...scales
* **stat** - statistical transformations

Reordered, the flow of information in ggplot2 is:

* **data** is attached to the ggplot call,
* mapped by **aes**, and
* transformed by **stat** before being passed to a
* **geom**,
* which is placed, sized, and colored according to its relevant **scales**
* then ta-da! rendered plot.

We already did step 1 above, by providing our iris dataset to `ggplot()`. Let's move onto aesthetic mapping.

## 3.1 Aesthetic Mapping

The basic idea is that we want to take our data and *map* it onto physical space using geometric objects or geoms. For ggplot to place a geom, it needs to know how the data map onto the aesthetics of the graph. Each `geom()` function in ggplot takes a `mapping` argument. Let's start with a basic geom, `geom_histogram()`.


Template for graphing in ggplot2:

ggplot(data = <DATA>) + 
  <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))

We're going to call ggplot()` again, and this time add the `geom_histogram()` *layer*, telling it to map the variable `Sepal.Length` to the x axis aesthetic:

```{r}
ggplot(data = iris) + # attach data
    geom_histogram(mapping = aes(x = Sepal.Length)) # add geom w/ aesthetic map
```

`geom_histogram()` only requires one *aesthetic mapping*, the x aesthetic, which tells it what variable it should map to the x axis.

Let's look at something just a tiny but more complicated: we'll add a layer of points to our plot (creating a scatterplot) using geom_point(). geom_point() is another *geom function*, each of which adds a different type of layer to a plot. Let's see what happens if we just give it an x variable to map:

```{r eval = FALSE}
ggplot(data = iris) + # attach data
    geom_point(mapping = aes(x = Sepal.Length)) # add geom w/ aesthetic map
```

We get an error, telling us that geom_point requires the y aesthetic to be defined. This makes sense - we need an x and y axis to define where points belong on a scatter plot. Let's add `Petal.Length` as the y axis:

```{r}
ggplot(data = iris) + # attach data
    geom_point(mapping = aes(x = Sepal.Length, y = Petal.Length)) # add geom w/ aesthetic map
```

That plot is

Let's find out if the relationship between `Sepal.Length` & `Petal.Length` relates to the `Species` of iris. To visualize this, we are going to map `Species` to an *aesthetic* (or a visual property of one of the objects in our plot). Aesthetics include things like size, shape, or color of our points. Let's map the color of our points to the `Species` variable.
```{r}
ggplot(data = iris) +
  geom_point(mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species))

#ggplot assigned each level of *color* to each unique value of `Species`. This is called *scaling*.
```
> **Exercise 8a.** Options for *aesthetics* include color, shape, size, and alpha. Create a scatter plot to visualize the relationship between `Sepal.Width` and `Petal.Width`. Add an aesthetic to visualize the effect of `Species`. Choose any aesthetic you'd like or play around with a few. What do they do? How might you use more than one aesthetic?

```{r}


```

> ProTip: We could also make separate graphs for each `Species` using `facet_wrap`. By passing a formula (data structure) to `facet_wrap`.

Here's how:
```{r}
ggplot(data = iris) +
  geom_point(mapping = aes(x = Sepal.Length, y = Petal.Length)) +
  facet_wrap(~ Species)
```
Maybe we'd prefer a line graph instead of a scatterplot to describe the `iris` data. In this case, we'd use a different *geom* (e.g., point, line, smooth, boxplot, bar). 

Let's make the same plot, using the smooth *geom* which fits a smoothed line to the data.
```{r}
ggplot(data = iris) +
  geom_smooth(mapping = aes(x = Sepal.Length, y = Petal.Length))

#loess is the default function for geom_smooth() 
# from http://www.statisticshowto.com/lowess-smoothing/: LOWESS (Locally Weighted Scatterplot Smoothing), sometimes called LOESS (locally weighted smoothing), is a popular tool used in regression analysis that creates a smooth line through a timeplot or scatter plot to help you to see relationship between variables and foresee trends.
```
We can add aesthetics to help visualize the data:
```{r}
ggplot(data = iris) +
  geom_smooth(mapping = aes(x = Sepal.Length, y = Petal.Length, linetype = Species))

ggplot(data = iris) +
  geom_smooth(mapping = aes(x = Sepal.Length, y = Petal.Length, linetype = Species, color = Species))
```
We can also layer multiple geoms in the same plot!
```{r}
ggplot(data = iris) +
  geom_point(mapping = aes(x = Sepal.Length, y = Petal.Length)) +
  geom_smooth(mapping = aes(x = Sepal.Length, y = Petal.Length))

#we could also have used global mappings
ggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) +
  geom_point() +
  geom_smooth()

#finally, we can add an *aesthetic* to only one part of the graph
ggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) +
  geom_point(mapping = aes(color = Species)) +
  geom_smooth()
```
> **Exercise 8b.** Plot the relationship between `Sepal.Width` and `Petal.Width`. As above, create lines overlaid on a scatter plot. For the points, use different colors for each `Species`. For the lines, use both different colors and line types for `Species`.

```{r}


```
Now let's try a bar plot. The bar chart below displays the total number of irises in the `iris` dataset, grouped by `Species`.
```{r}
ggplot(iris, aes(x = Species)) +
  geom_bar()
# not very interesting - it looks like there's an approximately equal number of irises for each species; note that geom_bar defaults to *count*. This would be more informative if we used another dataset that is built in to ggplot2 called `diamonds`.

ggplot(diamonds, aes(x = cut)) +
  geom_bar()
#this data set contains information about diamonds, and there are different numbers of diamonds at each level of `cut`
```
Let's get a more interesting plot for our `iris` dataset. We can look at the avearge `Sepal.Length` for each `Species` of iris.

First, we'll need to use the skills we've previously acquired to create a table of means that we'll then plot. We'll then use the argument stat = "identity" to map the mean value onto the y aesthetic.
```{r}
plot.data <- iris %>% 
  group_by(Species) %>% 
  summarise(mean = mean(Sepal.Length, na.rm=TRUE))

ggplot(plot.data, aes(x=Species, y=mean)) +
  geom_bar(stat="identity")

#more options:
ggplot(plot.data, aes(x=Species, y=mean, color=Species)) +
  geom_bar(stat="identity")

ggplot(plot.data, aes(x=Species, y=mean, fill=Species)) +
  geom_bar(stat="identity")
```
> **Exercise 8c.** Now, let's make a plot for ps_data. We want to visualize the mean `correct` for each `item` across each level of `condition`. Make sure the color of the bars represents the different `item`s. Instead of putting both levels of `condition` on the same plot, create two separate plots, one for each `condition`. Hint: use what you've learned so far about grouping and summarising; see *facet_wrap* above for help separating plots by `condition`!

```{r}


```